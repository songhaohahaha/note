# JS

# 阶段



## 第一天：

### JavaScript 浏览器脚本语言 

1.历史 ECMAScript 	 欧洲计算机制造联合会 	 统一JS标准   es6、es7

2.作用（生机活力、强大）：数据的验证； 操作dom元素内容、样式、属性； 动态的添加或删除页面中的元素；  动画；cookie、本地存储； “[阿贾克斯](https://baike.baidu.com/item/%E9%98%BF%E8%B4%BE%E5%85%8B%E6%96%AF)”ajax（动态获取数据）；...

##### 3.js组成：

*  ECMAScript

> 基础语法：变量，数据类型，运算符，执行流程，函数，对象

* BOM  浏览器browser对象object模型model+

>地址url统一资源定位符，历史记录，DOM、屏幕

* DOM   document object model文档对象模型

>节点

##### 4.引入方式  

> 通过<script> code </script> 嵌入任意位置
>
> 引入外部JS文件  在html中 <script src='index.js'></script>
>
> a标签href 和form中的action ，a链接，重定向

##### 5.调试工具

> 警示框  alert(); 数字随便写，汉字和字符用单引号或双引号括；
>
> 输出到控制台  console.log('');
>
> document.write(''); 输出到页面； 识别标签对；

### 注意事项：

* 允许引入多个JS文件，js文件是一个整体，相互联系，相互影响，相互作用
* 外部JS文件中，不允许script标签对；
* 如果引入的是一个外部的js文件，那么script的标签对中间不允许出现js代码；

#####  特点：

基于对象和事件驱动的松散型解释性语言；

> 松散型(弱)： 变量声明不考虑数据范围和类型，只需要 var； 分号；可以没有，变量可以在声明前调用，也可以在声明后调用
>
> 对象：有特征的一个东西
>
> 事件驱动：反馈

### 节省内存，方便？

##### 变量：

> 存储数据的一个容器；

声明：

> var 变量名 =  
>
> > 变量名必须由 数字、字母、下划线、$组成；
> >
> > > 数字不能开头；
> > >
> > > 变量区分大小写；
> >
> > 
> >
> > > 不能用关键字、保留字（class现在不用，以后可能会用的）来声明；

变量名有意义；

> 规则：首字母大写，驼峰命名法。

##### 赋值

先声明后赋值

> var a ;    a= 10;

声明的同时进行赋值；

> var a = 10;

一次性的声明多个变量，然后在进行赋值；

一次性声明多个变量，声明的同时进行赋值；

### 变量在用时要注意的问题：

变量的值可以修改更新；

变量允许重复声明同一个变量

> 如果不给新变量赋值，值还是原来的值；给新的变量赋值了，值是新的值；

声明一个变量需要var来修饰，如果不用var修饰，并且也没有赋值，会报错；

如果一个变量没有用var来修饰，直接赋值，这个变量会变成全局变量（不推荐）

变量声明了没有赋值，默认值是undefined；赋值之前调用这个变量，默认值也是undefined；

### 变量能存取哪些类型的数据？

##### 数据类型（2）

根据在内存中存储的位置



> 初始数据类型  （栈区：数据简单，读取快，信息少）
>
> > 1.undefined
> >
> > 2.number
> >
> > 3.string     在字符串中 \n 是换行， \\+转义字符，输出\要加\\    模板字符串： str1=`这是字符串，可以换行写`；输的时候是什么样子，就怎么显示；  esc下面的键。加号不再是拼接。num1要输出变量要用${包起来}
> >
> > 4.boolean
> >
> > 5.null 空  类型是对象 object；
>
> 复合数据类型	（堆区 数据复杂，读取慢，信息多）
>
> >对象object
> >
> >

### 检测数据

*typeof(variable)		 typeof variable

|   数据类型    |            值            |  typeof   |
| :-------: | :---------------------: | :-------: |
| undefined |        undefined        | undefined |
|  boolean  |       true/false        |  boolean  |
|   null    |          null           |  object   |
|  number   |  十进制、十六进制、二进制、八进制、特殊值   |  number   |
|  string   | 单引号或双引号包起来的字符（数字、字母、汉字） |  string   |
|  object   |       属性和方法的无序集合        |  object   |

0b 二进制

0o八进制

0x十六进制

alert（Number.MAX_VALUE）;

### 如何操作数据？

### 运算符

##### 算数运算符

> 加+，减-，乘*，除/，取余%，++，--
>
> % 取余 得到某一个范围之内的数；想
>
> +加号 两边是数字的时候是求和，两边不同时是连接字符串。
>
> var++ 先运算后自增；++var 先自增后参与运算

NAN    NOT  A    NUMBER；  undefined++     →      NAN

变量才可以进行 ++，--运算；

只要有值的语句或代码段就是一个表达式；

### string

.string     在字符串中 \n 是换行， \\+转义字符，输出\要加\\  

 模板字符串： str1=`这是字符串，可以换行写`；输的时候是什么样子，就怎么显示；  esc下面的键。加号不再是拼接。num1要输出变量要用${包起来}







# 第二天

### 赋值运算符

 =	  +=	  -=	   *=	  /= 	   %=

>  a = a+5；   a+=5；

### 关系运算符（比较运算符）

   ``` >   =     <    >=   <=     ==  是否等于  ===是否完全等于   != 不等于  !==完全不等于	  ```

> 运算结果是布尔值；

* 两个数字比较，正数>0>负数


* 两个字符串比较，比较两个字符串首字符的ASCII码，ASCII码值大的所在的字符串就大；如果第一个字符相同，比较第二个、第三个	···；


* 两个数字型的字符串，同上；


* 数字和字符串进行比较，尝试着将字符串转化成数字，按照数字的规则进行比较，如果转化不成功返回NaN，整个表达式返回false；


* 数字和布尔值进行比较，true 转化成1，false转化成0


* undefined == null 成立

  1 == true   成立  只比较数值；

1 === true  不成立  还要比较数据类型；

字符串的比较， 一位一位比；   '10'<'2'      'ba'>'b'      '10'与'2px' 没法比，结果是false；4



### 逻辑运算符

```&&与and   ||或or		！非not```

逻辑运算符在判断时，如果两边都是真的，值是最后一个条件的值。   num &&  num1  ；

如果两边有假的时候，输出的值是第一个为假的时候的值。

短路现象：遇到假的不执行后面；



###false 0  null   undefined  空字符串（''） NaN         》》都是假的，其余都是真

### 三元表达式

#### num%2==0 ? true : false;    type = type == undefined   ? '<'  : type;   				     type = type ||  ‘<’;

##### new 创建一个对象      delete 删除一个对象的属性    一元运算符  num = -10 负号。+正号

();改变优先级； 调用函数；  

，声明多个变量的时候隔开变量

...扩展数组



### 执行流程：

* 顺序结构：整体流程  从上往下；


* 分支结构（选择结构）：   

  * 单路分支

  > >  if(条件){
  > >
  > >  ​	```//条件成立后要执行的代码```
  > >
  > >  }
  > >
  > >  * 双路分支
  >
  > ​
  >
  > > if(条件){
  > >
  > > ​	```//条件成立后要执行的代码```
  > >
  > > }else{
  > >
  > > ​	```//条件不成立后要执行的代码```
  > >
  > > }
  >
  > 多路分支
  >
  > > ``` if(条件1){``` 
  > >
  > > ​	条件1成立执行的代码
  > >
  > > ```}```else if （条件2）{
  > >
  > > ​	条件2成立执行的代码
  > >
  > > }else if （条件3）{
  > >
  > > ​	条件3成立执行的代码
  > >
  > > }else{
  > >
  > > ​	上述条件都不满足，执行的代码
  > >
  > > }

> switch

​	switch（值）{

​	case 情况1 ：

​		代码；

​	break；

​	case 情况2 ：

​		代码；

​	break；

 	default:

​		上述情况都不满足；

​	}

* 循环
  * 在满足条件的情况下，不停的执行某一段代码；

##### 分支结构条件：条件的范围最好不要有重复的；

条件是一个范围，优先考虑 if； 条件是某一个定值，并且情况是可数的，优先考虑用switch；







# 第三天+第四天

## 数组

##### 存储一系列相同的，相关的数据的容器；

方便管理数据；逻辑结构清晰、代码方便维护；

##### 声明一个数组  var arr = [ ]; 

​			 var arr1 = new Array();

##### 赋值：

> 声明同时进行赋值  
>
> 先声明后赋值   arr[0] = 1,arr[2]=5;

#### 2通过下标的方式来访问

> 下标从**0**开始 	arr[0] arr[1]   
>
> 最大 ： arr.length222-1

#### 遍历

> for(var i =0;i<arr.length;i++){



> ​	arr[i];



> }

### 二维数组

```class [1][2]``

### 注意

* 数组元素默认undefined ；
* 数组的长度可变；
* 数组元素可以是任意的数据类型；

## 循环

#### for循环

* for(初始值，最终值，变化量){

     循环体

  ​}

* 循环的次数由初始值，最终值，变化量决定。

### while循环

* while 先判断条件，如果条件成立，执行循环体，如果条件成立，继续执行循环体，直到条件不成立，结束循环


* do while 先执行循环体，然后判断条件，如果条件成立继续执行循环体，直到条件不成立，结束循环。

 var i=1;

while(循环条件){

​	循环体；

​	变化量；

}

do{

​	sum+=i;

​	i++;

}while(i<=10)



* do{}while(); 和while区别： do  while会先执行一次再判断条件，while会先判断条件再执行。（当它的初始值不满足循环条件的时候，while一次都不循环，do while会做一次循环。）

  ​

##### 对比：如果知道循环次数，优先用for循环写，如果只知道循环条件，考虑while，do while来写。



### 循环跳转语句

> continue  ：跳过当前这次循环；如果条件成立，它会继续执行循环。



> break： 跳出整个循环；终止break所在的循环；

max

是否为空  newarr   length

##### typeof 弹出的数据类型为 string;





## 函数

实现某一个特定功能的代码段打包封装，然后重复调用。

##### 函数内部会动态自动创建 arguments ***对象***，智能函数内部调用，能保存实参的信息，

优点：1.重复调用 2.逻辑结构、清晰 3.方便维护、开发

* 基本语法方式声明： function fn([形参1]，[形参2]···){ 函数体 [ return]}	调用：  fn();   可以在页面任何位置调用；


* 字面量方式声明   var  fn = function(){}    调用：  fn();  只能在代码后面调用；在前面是undefined，会报错；
* 面向对象的方式创建    new  Function(形参1，形参2，···，函数体)

### 参数  

##### 动态改变函数体内部变量，让函数变得灵活强大

#### 默认值：1.分支结构     2.三元表达式    3.逻辑或||    4.ES6的新方法

####   type = type == undefined   ? '<'  : type;        type = type ||  ‘ < ’ ;        直接在  function（arr，type=‘<’）默认值就是<   或者分支结构来写。

#### 带有默认值的参数写到最后；实参是undefined，还是默认值；

* 形参 （rows，cols）；  函数定义的时候写在括号里的，没有实际值；用来接收实参传递的值；

* 实参，函数调用的时候，小括号里面的值；

  > 参数 可以是任意数据类型        形参数量比实参多，没有给实参传值，是undefined； 形参比实参少，只给形参数量的实参值。

  ##### 剩余参数   必须写到参数的最后面； 没有形参和它对应的实参；

  ...value；数据类型：数组； 如果没有剩余参数，空数组；

  function fn(arr,...rest){用的时候直接rest}


### 调用 

* 函数名（）；   自变量（）；
* 事件后面    divs.onclick = function (){}   事件触发的时候
* 自调用函数  （立即执行函数）；  没有函数名，只需要执行一次，就用自调用函数； 把函数用（）括起来 再加一个()；   (function (){})(); 

### 函数注意事项

* 函数名相同了，后面的函数覆盖掉原来的函数
* 基本语法声明的函数 可以在任意位置调用；
* 以字面量声明的函数 只能在 后面调用；


### return 返回值 【返回值；终止函数】

* 在函数调用的地方返回一个值，如果写多个值，显示最后一个；默认undefined；
* 函数的返回值可以是任意的数据类型；
* 终止函数执行，return后面的代码不会执行


* 函数允许写多个return（分支），只会执行一个；


### 作用域 

> 一个变量起作用的范围；函数也有作用域；
>
> 作用域 由执行环境决定

* 全局作用域: 任意范围 
* * 定义在函数的最外层  或者 一个变量不用 var来声明它；
* 局部作用域: 某一个特定的函数    用完会释放掉，节省页面空间
* * 定义在函数内部

### JS在宿主环境下运行；

##### 预编译

* 按照从上到下   script 
* var   function  变量名和函数名预先放置内存，记录声明的环境。
* 执行

map 映射

# 第五天

* ...rest   在函数里面是合并成数组。在外面是逆运算，拆分数组成值

* 函数自己调用自己本身， 递归函数；  不是循环；不能是死的，需要一个出口；

  function fn(num){

  ​	if(num<5){

  ​		fn(++num)

  ​	}

  ​	alert(num);

  }

  ###

>  传地址 浅拷贝   

>  传值  深拷贝    结合递归使用；

# 第二周

## 第一天

### 递归函数  ：

* 函数中调用本身函数

###回调函数  :

* 映射中 的 fn参数就是回调函数

###闭包函数：

* 在函数内部嵌套一个函数，将里面的函数当成返回值返回回来，然后再调用它的返回值，从而实现调用里面变量的目的。

### 箭头函数:

#####一般结合回调函数使用

​	var fn = function(a){			 	

​		return a;

​	}

​	var fn = function(){

​		return a;

​	}

#####等价于   var fn = a => a;	 如果没有形参 var fn = () => a;		如果参数多要用括号括起来

​	如果代码多，要用大括号括起来       var fn = (a,,b) => {	};

​	var result = map(arr,function(value){

​	return value -2})

#####等价于 var result1 = map(arr,(value) => value-2);

#####注意事项：箭头函数 没有arguments  没有this指向，没有构造函数;

### 声明变量Let

####（先声明后调用）

* 基本用法：let num = 10；和var用法一样
* 变量的提升：let不存在变量的提升，声明过后不能再次声明；
* 暂时性死区：声明之前是暂时性的死区，不能访问，会报错；
* 在同一个作用域里不允许多次声明同一个变量；

用let循环，每一次循环都是一个新的作用域，所以值每个都不一样。

### var的缺点

* 内存泄漏（for）；
* 局部变量可能覆盖全局变量；

### 块级作用域

* 块级作用域   ： 在一个{}里面起作用；
* 块级作用域嵌套；


### 声明常量  const

#####const pi = 3.14；不允许修改，不允许声明之后再赋值。识别块级作用域。【和let相似】

###内置顶层函数（内置的全局函数）

##### 内置：js自己定义的函数，不需要关心如何实现，直接用

#####顶层：在任意的位置来调用函数；（强制类型转换）

* let  str='汉字'      escape(str)将传进来的非字母数字的字符进行编码，
* unescape()   对编码后的字符进行解码
* Number()  将其他数据类型转化成数字   undefined是NaN   null》0  true》1 false》0，数字转化其他进制转为10进制；忽略一些无意义的0；字符串：数字型的字符串100px不能；**空字符串是0**；如果开头是0，且不是字符串，会转为8进制；
* String()
* Boolean()        false； 0 ； null ；  undefined  ；空字符串（''）；NaN     ；    是假的，其余都是真
* parseInt()       字符串转化成整数；第一个数字开始到第一个非数字结束。数字，+，-，空格开头。
* parseFloat()   转化成小数；
* isNaN()    不是一个数字？ 如果里面的只要可以转化为数字，返回false，如果里面不是一个数字，返回true。

### 隐士类型转换

* 算术运算符中除了加法
* 关系运算符 
* 逻辑运算符
* if   while  三元表达式；

### 对象object

#####属性和方法的无序集合

数组对象，函数对象，日期对象，正则对象     自定义对象；

属性就是能看到的表层，方法就是一个内在，一个函数；

####定义对象：

* 原生json方法：let  mingzi = { } 
* 构造函数：  先写一个类，也就是一个函数 function Person(){}   然后 let zhangsan = new  Person(); 创建一个对象。

####给对象添加属性和方法

谁，什么属性，等于什么

zhangsan.age  = 18；

zhangsan.name = 'zhangsan'

#### 访问对象

谁，什么属性   zhangsan.age